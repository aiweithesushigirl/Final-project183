import peasy.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import com.hamoid.*;
import ddf.minim.ugens.*;



Minim minim;
AudioPlayer song;
BeatDetect beat;
ddf.minim.analysis.FFT fft;

//float x = 0.01;
//float y = 0;
//float z = 0;

//float a = 10;
//float b = 28;
//float c = 8.0/3.0;

//float[] real;
//float[] img;
//PVector offset1 = new PVector(1,1,1);
//PVector offset2;
//PVector offset3;

//PVector offset4 = new PVector(1,1,1);
//PVector offset5;
//PVector offset6;
//ArrayList<PVector> points = new ArrayList<PVector>();



PeasyCam cam;

//float specLow = 0.03; // 3%
//float specMid = 0.125;  // 12.5%
//float specHi = 0.20;   // 20%


//float scoreLow = 0;
//float scoreMid = 0;
//float scoreHi = 0;
float speedmap = 0;

//float oldScoreLow = scoreLow;
//float oldScoreMid = scoreMid;
//float oldScoreHi = scoreHi;


//float scoreDecreaseRate = 25;
Star[] stars = new Star[300];

float speed;
//float m = 0;


//void setup() {
//  //fullScreen(P3D);
//  size(500, 400,P3D);
//  colorMode(HSB);
//  smooth(4);
//  cam = new PeasyCam(this, 500);
//  minim = new Minim(this);
//    for (int i = 0; i < stars.length; i++) {
//    stars[i] = new Star();
//  }
 




//  song = minim.loadFile("1973.mp3",128);

  
//  song.play();
//  beat = new BeatDetect();
//  fft = new ddf.minim.analysis.FFT(song.bufferSize(), song.sampleRate());
//}

//void draw() {
//  background(0);

  
//  fft.forward(song.right);
//  beat.detect(song.mix);
//  real = fft.getSpectrumReal();
//  img = fft.getSpectrumImaginary();
  

//  //float fov = PI/3;
//  //float cameraZ = (height/2.0) / tan(fov/2.0);
//  //perspective(fov, float(width)/float(height), cameraZ/10.0, cameraZ*10.0);
//  phy.show();

//  float dt = 0.01;
//  float dx = (a * (y - x))*dt;
//  float dy = (x * (b - z) - y)*dt;
//  float dz = (x * y - c * z)*dt;
//  x = x + dx;
//  y = y + dy;
//  z = z + dz;


//  points.add(new PVector(x, y, z));

//  oldScoreLow = scoreLow;
//  oldScoreMid = scoreMid;
//  oldScoreHi = scoreHi;

//  scoreLow = 0;
//  scoreMid = 0;
//  scoreHi = 0;

  
//  for (int i = 0; i < fft.specSize()*specLow; i++)
//  {
//    scoreLow += fft.getFreq(i);
//    speedmap = fft.getBand(i);
//  }

//  for (int i = (int)(fft.specSize()*specLow); i < fft.specSize()*specMid; i++)
//  {
//    scoreMid += fft.getFreq(i);
//  }

//  for (int i = (int)(fft.specSize()*specMid); i < fft.specSize()*specHi; i++)
//  {
//    scoreHi += fft.getFreq(i);
//  }


//  if (oldScoreLow > scoreLow) {
//    scoreLow = oldScoreLow - scoreDecreaseRate;
//  }

//  if (oldScoreMid > scoreMid) {
//    scoreMid = oldScoreMid - scoreDecreaseRate;
//  }

//  if (oldScoreHi > scoreHi) {
//    scoreHi = oldScoreHi - scoreDecreaseRate;
//  }

//  PVector newvec = new PVector(scoreLow/100, scoreMid/100, scoreHi/100);
//  float hu = 0;
//  float hu2 = 0;
//  float transparency = 255;

//  points.add (newvec);
  
//  speed = map(speedmap*50, 0, width, 0, 100);
//  for (int i = 0; i < stars.length; ++i){
  
//     stars[i].c = color(hu2, 255, 255, transparency);
//     stars[i].update();
//     stars[i].show();
//     hu2 += 0.5;
//     if (hu2 > 255) {
//        hu2 = 0;
//      }
//   }

//  //translate(width/2, height/2);




//  translate(0, 0, -200);
//  //translate(width/2, height/2);
//  scale(5);
//  stroke(255);
  
//  noFill();  

  
//  //if (beat.isOnset()){
//  //  lights();

  


  
//  float x_val = 1;
  

//  beginShape();
//  for (PVector v : points) {
//    stroke(hu, 255, 255, transparency);
//    strokeWeight(1);
//    //pushMatrix();
//    vertex(v.x, v.y, v.z);
//    //vertex(v.x, v.y, v.z);
//    //vertex(v.x, v.y-10, v.z);
//    //vertex(v.x, v.y, v.z+10);
//    //vertex(v.x-10, v.y, v.z+10);
//    //box(3);
//    //popMatrix();
//    rotate(PI/720);

 

//    PVector offset1 = new PVector(1,1,x_val);

    
//    for (int i = 0; i < fft.specSize(); ++i){
      
//     // vertex(v.x, v.y+fft.getBand(i), v.z);
//      PVector offset2 = new PVector(fft.getBand(i)/100,fft.getBand(i)/100,1);
//      offset1.mult(fft.getBand(i)/10);
//      //offset2.mult(fft.getBand(i)/10);
//      v.add(offset1);
//      x_val = real[i];
      
//      //ellipse(v.x, v.y, x_val/2, y_val/2);
//      if (beat.isOnset()){
//         v.add(offset2);
//      }
      
//      //rotate(PI/36000);
      
      
//    }
    
    

//    hu += 0.1;
//    transparency--;
//    if (hu > 255) {
//      hu = 0;
//    }
//    if (transparency < 50){
//      transparency = 255;
//    }
    
//  }
//  endShape();




//}

float n = 0;
float c = 4;

ArrayList<PVector> points = new ArrayList<PVector>();

float start = 0;

void setup() {
  
  colorMode(HSB, 360, 255, 255);
  size(800, 800,P3D);
  smooth(4);
  cam = new PeasyCam(this, 500);
  minim = new Minim(this);
    for (int i = 0; i < stars.length; i++) {
    stars[i] = new Star();
  }

  song = minim.loadFile("1973.mp3",128);

  
  song.play();
  beat = new BeatDetect();
  fft = new ddf.minim.analysis.FFT(song.bufferSize(), song.sampleRate());
}

void draw() {
  background(0);
  fft.forward(song.right);
  beat.detect(song.mix);
  float hu2 = 0; 

  for (int i = 0; i < fft.specSize()*0.3; i++)
  {
    speedmap = fft.getBand(i);
    //println(speedmap);
  }
  speed = map(speedmap*50, 0, width, 0, 50);
  for (int i = 0; i < stars.length; ++i){
     stars[i].update();
     stars[i].show();
     hu2 += 0.5;
     if (hu2 > 255) {
        hu2 = 0;
      }
   }
  translate(width / 2, height / 2);
  //rotate(n * 0.3);
  for (int i = 0; i < n; i++) {
    float a = i * radians(137.5);
    float r = c * sqrt(i);
    float x = r * cos(a) - width/2;
    float y = r * sin(a) - height/2;
    float hu = i+start;//sin(start + i * 0.5);
    hu = i/3.0 % 360;
    fill(hu, 255, 255);
    noStroke();
    ellipse(x, y, 4, 4);
  }
  n += speedmap*10;
  start += 5;
  
  if (n > 500){
    n = 0;
  }
}
